<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Neon Hand FX PRO</title>
  <style>
    :root{
      --bg1:#05000f;
      --bg2:#020b18;
      --neon:#66ccff;
      --neon2:#ff4fd8;
      --text:#eaf2ff;
    }
    body { margin:0; background: radial-gradient(1200px 900px at 20% 20%, #14003a 0%, var(--bg1) 35%, var(--bg2) 100%); color: var(--text); font-family: system-ui,-apple-system,Arial; }
    #wrap { position: relative; width: 100vw; height: 100vh; overflow: hidden; }

    /* ‚úÖ 2-usul: kamera ekranga CHIQMAYDI (butunlay yashirin), lekin tracking ishlaydi */
    video{
  position:absolute;
  inset:0;
  width:100%;
  height:100%;
  object-fit:cover;
  transform: scaleX(-1);
  opacity: 0;           /* üëà ko‚Äòrinmaydi, lekin ishlaydi */
  pointer-events:none;
}

    canvas { position:absolute; inset:0; display:block; }

    /* Vignette + grain (chiroyli ‚Äúcinematic‚Äù ko‚Äòrinish) */
    #wrap::before{
      content:"";
      position:absolute; inset:-20%;
      background:
        radial-gradient(900px 700px at 50% 45%, rgba(0,0,0,0) 0%, rgba(0,0,0,.25) 45%, rgba(0,0,0,.55) 75%, rgba(0,0,0,.75) 100%),
        radial-gradient(900px 900px at 85% 25%, rgba(102,204,255,.10) 0%, rgba(0,0,0,0) 55%),
        radial-gradient(900px 900px at 20% 80%, rgba(255,79,216,.08) 0%, rgba(0,0,0,0) 55%);
      pointer-events:none;
      mix-blend-mode: normal;
    }
    #wrap::after{
      content:"";
      position:absolute; inset:0;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='140' height='140'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.9' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='140' height='140' filter='url(%23n)' opacity='.18'/%3E%3C/svg%3E");
      opacity:.08;
      pointer-events:none;
      mix-blend-mode: overlay;
    }

    /* UI */
    .top {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius: 14px; backdrop-filter: blur(10px);
      max-width: calc(100vw - 24px);
      box-shadow: 0 10px 35px rgba(0,0,0,.35);
    }
    button { padding:10px 14px; border-radius:12px; border:0; cursor:pointer; background: linear-gradient(135deg, rgba(102,204,255,.9), rgba(255,79,216,.75)); color:#06121a; font-weight:700; }
    .badge { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); font-size: 13px; }
    #hint { font-size: 13px; opacity:.92; }
  </style>
</head>
<body>
  <div class="top">
    <button id="startBtn">‚ö° Start</button>
    <span class="badge" id="status">Status: ready</span>
    <span id="hint">
      ü§è Pinch = energiya yig‚Äòish ‚Ä¢ ‚úã Open hand = portlash ‚Ä¢ ‚úä Fist = freeze ‚Ä¢ ‚ÜïÔ∏è Pinch+yuqori/past = zoom
    </span>
  </div>

  <div id="wrap">
    <video id="video" playsinline></video>
    <canvas id="three"></canvas>
  </div>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const video = document.getElementById("video");
    const canvas = document.getElementById("three");
    const wrap = document.getElementById("wrap");
    const statusEl = document.getElementById("status");
    const startBtn = document.getElementById("startBtn");
    const setStatus = (t)=> statusEl.textContent = "Status: " + t;

    // ---------- THREE ----------
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x05000f, 0.085);

    const cam = new THREE.PerspectiveCamera(58, 1, 0.01, 120);
    cam.position.set(0, 0.7, 2.9);

    const ambient = new THREE.AmbientLight(0xffffff, 0.28);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xffffff, 0.85);
    key.position.set(2.2, 3.2, 1.5);
    scene.add(key);

    const rim1 = new THREE.DirectionalLight(0x66ccff, 0.55);
    rim1.position.set(-2.2, 1.8, -2.2);
    scene.add(rim1);

    const rim2 = new THREE.DirectionalLight(0xff4fd8, 0.35);
    rim2.position.set(1.0, 1.2, -2.8);
    scene.add(rim2);

    function resize(){
      const w = wrap.clientWidth, h = wrap.clientHeight;
      renderer.setSize(w, h, false);
      cam.aspect = w / h;
      cam.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    // ---------- NEBULA STARFIELD ----------
    const STAR_COUNT = 1900;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(STAR_COUNT * 3);
    const starCol = new Float32Array(STAR_COUNT * 3);

    function randn(){ return (Math.random()+Math.random()+Math.random()+Math.random()-2); }

    for (let i=0;i<STAR_COUNT;i++){
      const x = randn()*2.6;
      const y = randn()*1.8 + 0.3;
      const z = - (Math.random()*12 + 2);

      starPos[i*3+0]=x;
      starPos[i*3+1]=y;
      starPos[i*3+2]=z;

      // color mix neon/white
      const t = Math.random();
      const c1 = new THREE.Color(0x66ccff);
      const c2 = new THREE.Color(0xff4fd8);
      const c3 = new THREE.Color(0xffffff);
      const c = c1.clone().lerp(c2, Math.random()*0.55).lerp(c3, Math.random()*0.35);
      starCol[i*3+0]=c.r;
      starCol[i*3+1]=c.g;
      starCol[i*3+2]=c.b;
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    starGeo.setAttribute("color", new THREE.BufferAttribute(starCol, 3));

    const starMat = new THREE.PointsMaterial({
      size: 0.022,
      vertexColors: true,
      transparent: true,
      opacity: 0.85,
      depthWrite: false
    });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // ---------- MAIN ORB (premium glow) ----------
    const orb = new THREE.Mesh(
      new THREE.SphereGeometry(0.16, 56, 56),
      new THREE.MeshStandardMaterial({
        color: 0xffffff,
        metalness: 0.3,
        roughness: 0.18,
        emissive: 0x113355,
        emissiveIntensity: 0.7
      })
    );
    orb.position.set(0, 0.55, 0);
    scene.add(orb);

    // layered glow (fake bloom)
    const glow1 = new THREE.Mesh(
      new THREE.SphereGeometry(0.25, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent:true, opacity: 0.12 })
    );
    const glow2 = new THREE.Mesh(
      new THREE.SphereGeometry(0.34, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0xff4fd8, transparent:true, opacity: 0.06 })
    );
    scene.add(glow1, glow2);

    // ---------- HAND NEON (points + segments + trail) ----------
    const MAX = 21;
    const CONN = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],
      [0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20],
      [5,9],[9,13],[13,17]
    ];
    const segCount = CONN.length;

    const handGeo = new THREE.BufferGeometry();
    const handPos = new Float32Array(MAX*3);
    handGeo.setAttribute("position", new THREE.BufferAttribute(handPos, 3));

    const handPts = new THREE.Points(
      handGeo,
      new THREE.PointsMaterial({ color: 0x66ccff, size: 0.032, transparent:true, opacity: 0.0, depthWrite:false })
    );
    scene.add(handPts);

    const segGeo = new THREE.BufferGeometry();
    const segPos = new Float32Array(segCount*2*3);
    segGeo.setAttribute("position", new THREE.BufferAttribute(segPos, 3));

    const handLines = new THREE.LineSegments(
      segGeo,
      new THREE.LineBasicMaterial({ color: 0x55ccff, transparent:true, opacity: 0.0 })
    );
    scene.add(handLines);

    // fingertip trail (adds ‚Äúwow‚Äù)
    const TRAIL = 120;
    const trailGeo = new THREE.BufferGeometry();
    const trailPos = new Float32Array(TRAIL*3);
    trailGeo.setAttribute("position", new THREE.BufferAttribute(trailPos, 3));
    const trailMat = new THREE.LineBasicMaterial({ color: 0xff4fd8, transparent:true, opacity: 0.0 });
    const trailLine = new THREE.Line(trailGeo, trailMat);
    scene.add(trailLine);

    function pushTrail(p){
      for (let i=TRAIL-1;i>0;i--){
        trailPos[i*3+0]=trailPos[(i-1)*3+0];
        trailPos[i*3+1]=trailPos[(i-1)*3+1];
        trailPos[i*3+2]=trailPos[(i-1)*3+2];
      }
      trailPos[0]=p.x; trailPos[1]=p.y; trailPos[2]=p.z;
      trailGeo.attributes.position.needsUpdate = true;
    }

    // ---------- BURST PARTICLES ----------
    const BURST_MAX = 1200;
    const burstGeo = new THREE.BufferGeometry();
    const burstPos = new Float32Array(BURST_MAX*3);
    const burstVel = new Float32Array(BURST_MAX*3);
    const burstLife = new Float32Array(BURST_MAX);
    burstGeo.setAttribute("position", new THREE.BufferAttribute(burstPos, 3));
    const burstMat = new THREE.PointsMaterial({ color: 0x88ddff, size: 0.03, transparent:true, opacity: 0.0, depthWrite:false });
    const burst = new THREE.Points(burstGeo, burstMat);
    scene.add(burst);

    function spawnBurst(at, power){
      const n = Math.floor(260 + power * 620);
      for (let i=0;i<n;i++){
        const idx = (Math.random()*BURST_MAX)|0;
        burstPos[idx*3+0]=at.x;
        burstPos[idx*3+1]=at.y;
        burstPos[idx*3+2]=at.z;

        const a = Math.random()*Math.PI*2;
        const u = (Math.random()*2-1);
        const s = Math.sqrt(1-u*u);
        const speed = 1.1 + Math.random()*(2.6 + power*2.2);

        burstVel[idx*3+0]=Math.cos(a)*s*speed;
        burstVel[idx*3+1]=u*speed;
        burstVel[idx*3+2]=Math.sin(a)*s*speed;

        burstLife[idx]=0.5 + Math.random()*(0.9 + power*0.8);
      }
      burstMat.opacity = 0.9;
      burstGeo.attributes.position.needsUpdate = true;
    }

    // ---------- INPUT / GESTURES ----------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);

    function dist(a,b){
      const dx=a.x-b.x, dy=a.y-b.y;
      return Math.sqrt(dx*dx+dy*dy);
    }

    // pinch threshold
    function isPinch(lm){ return dist(lm[4], lm[8]) < 0.082; }

    // hand openness: average tip-to-palm distance
    function openness(lm){
      const palm = lm[0];
      const tips = [4,8,12,16,20];
      let s=0;
      for (const t of tips) s += dist(lm[t], palm);
      return s / tips.length; // ~ 0.10..0.35
    }
    function isOpenHand(lm){ return openness(lm) > 0.23; }
    function isFist(lm){ return openness(lm) < 0.16; }

    // smoothing
    let smooth = {x:0, y:0};
    const ALPHA = 0.24;
    function smoothN(n){
      smooth.x += (n.x - smooth.x) * ALPHA;
      smooth.y += (n.y - smooth.y) * ALPHA;
      return {x:smooth.x, y:smooth.y};
    }
    function landmarkToNDC(lm){
      const x = (1 - lm.x)*2 - 1;
      const y = -(lm.y*2 - 1);
      return {x,y};
    }

    function ndcToWorldOnPlane(n){
      ndc.set(n.x, n.y);
      raycaster.setFromCamera(ndc, cam);
      const hit = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, hit);
      return hit;
    }

    // state
    let pinching=false;
    let energy=0;                 // 0..1.8
    let freeze=false;
    let lastOpen=false;
    let lastFist=false;

    function updateHandNeon(lm){
      const baseZ = -0.75;
      for (let i=0;i<MAX;i++){
        const x = (0.5 - lm[i].x)*1.65;
        const y = (0.5 - lm[i].y)*-1.25 + 0.62;
        const z = baseZ + (lm[i].z || 0)*0.95;
        handPos[i*3+0]=x; handPos[i*3+1]=y; handPos[i*3+2]=z;
      }
      handGeo.attributes.position.needsUpdate = true;

      for (let s=0;s<segCount;s++){
        const [a,b]=CONN[s];
        segPos[s*6+0]=handPos[a*3+0];
        segPos[s*6+1]=handPos[a*3+1];
        segPos[s*6+2]=handPos[a*3+2];
        segPos[s*6+3]=handPos[b*3+0];
        segPos[s*6+4]=handPos[b*3+1];
        segPos[s*6+5]=handPos[b*3+2];
      }
      segGeo.attributes.position.needsUpdate = true;

      // show neon
      handPts.material.opacity = 0.92;
      handLines.material.opacity = 0.55;

      // energy affects brightness
      const e = Math.min(1.0, energy/1.4);
      handLines.material.opacity = 0.45 + e*0.35;
      trailMat.opacity = 0.12 + e*0.42;
    }

    // ---------- MEDIAPIPE ----------
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.78,
      minTrackingConfidence: 0.78
    });

    hands.onResults((res) => {
      if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0){
        setStatus(freeze ? "freeze (qo‚Äòl yo‚Äòq)" : "qo‚Äòl topilmadi");
        handPts.material.opacity = 0.0;
        handLines.material.opacity = 0.0;
        trailMat.opacity *= 0.92;
        pinching=false;
        lastOpen=false;
        lastFist=false;
        return;
      }

      const lm = res.multiHandLandmarks[0];
      updateHandNeon(lm);

      const pinchNow = isPinch(lm);
      const openNow = isOpenHand(lm);
      const fistNow = isFist(lm);

      // ‚úä Fist toggles freeze (edge trigger)
      if (fistNow && !lastFist){
        freeze = !freeze;
        setStatus(freeze ? "freeze ON" : "freeze OFF");
      }
      lastFist = fistNow;

      // Open hand triggers burst (edge trigger)
      if (openNow && !lastOpen){
        // burst even without pinch, small power
        spawnBurst(orb.position, Math.min(1.2, 0.35 + energy));
        energy = 0;
      }
      lastOpen = openNow;

      // tracking point (index tip)
      const raw = landmarkToNDC(lm[8]);
      const n = smoothN(raw);

      // fingertip world-ish point for trail (use neon space, not plane)
      const tip3 = new THREE.Vector3(handPos[8*3+0], handPos[8*3+1], handPos[8*3+2]);
      pushTrail(tip3);

      if (!freeze){
        if (pinchNow){
          // orb follow + charge
          const hit = ndcToWorldOnPlane(n);
          orb.position.x = hit.x;
          orb.position.z = hit.z;

          const yUp = THREE.MathUtils.clamp((1 - (n.y + 1)/2) * 1.9, 0.10, 1.95);
          orb.position.y = yUp;

          energy = Math.min(1.8, energy + 0.04);

          // pinch+up/down = zoom (camera)
          const zoom = THREE.MathUtils.clamp(3.3 - yUp*0.9, 1.8, 4.2);
          cam.position.z = cam.position.z + (zoom - cam.position.z)*0.10;

          setStatus("pinch (energy " + energy.toFixed(2) + ")");
        } else {
          setStatus(freeze ? "freeze" : "ready");
        }
      } else {
        setStatus("freeze ON");
      }

      // release pinch -> burst using energy
      if (!pinchNow && pinching && !freeze){
        spawnBurst(orb.position, energy);
        energy = 0;
      }
      pinching = pinchNow;
    });

    // ---------- CAMERA START ----------
    let mpCamera;
    startBtn.addEventListener("click", async () => {
      try{
        setStatus("kamera so‚Äòralyapti...");
        const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode:"user" }, audio:false });
        video.srcObject = stream;
        await video.play();

        mpCamera = new Camera(video, {
          onFrame: async () => { await hands.send({ image: video }); },
          width: 1280, height: 720
        });
        mpCamera.start();
        setStatus("running");
      }catch(e){
        console.error(e);
        setStatus("kamera ochilmadi");
        alert("Kamera ochilmadi. Safari ruxsatlarini tekshiring.");
      }
    });

    // ---------- ANIMATION ----------
    function tick(){
      const t = performance.now() * 0.001;

      // stars drift
      stars.rotation.y = t * 0.06;
      stars.position.x = Math.sin(t*0.08) * 0.15;

      // glow pulse with energy
      glow1.position.copy(orb.position);
      glow2.position.copy(orb.position);

      const e = Math.min(1.0, energy/1.4);
      glow1.material.opacity = 0.10 + e*0.25 + Math.sin(t*6)*0.02;
      glow2.material.opacity = 0.05 + e*0.14 + Math.sin(t*4+1.3)*0.015;

      orb.material.emissiveIntensity = 0.65 + e*1.15;

      // burst physics
      let alive = 0;
      for (let i=0;i<BURST_MAX;i++){
        if (burstLife[i] > 0){
          alive++;
          burstLife[i] -= 0.016;
          burstPos[i*3+0] += burstVel[i*3+0] * 0.016;
          burstPos[i*3+1] += burstVel[i*3+1] * 0.016;
          burstPos[i*3+2] += burstVel[i*3+2] * 0.016;

          burstVel[i*3+1] -= 0.95 * 0.016;
          burstVel[i*3+0] *= 0.986;
          burstVel[i*3+1] *= 0.986;
          burstVel[i*3+2] *= 0.986;
        }
      }
      if (alive === 0) burstMat.opacity *= 0.92;
      else burstMat.opacity = Math.max(0.25, burstMat.opacity * 0.987);
      burstGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, cam);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>