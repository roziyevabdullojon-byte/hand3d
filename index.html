<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>WOW Hand FX (Three.js + MediaPipe)</title>
  <style>
    body { margin:0; background:#02040a; color:#e8eef6; font-family: system-ui, -apple-system, Arial; }
    .top {
      position: fixed; left: 12px; top: 12px; z-index: 10;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background: rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);
      padding:10px 12px; border-radius: 14px; backdrop-filter: blur(8px);
      max-width: calc(100vw - 24px);
    }
    button { padding:10px 14px; border-radius:12px; border:0; cursor:pointer; }
    .badge { padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); font-size: 13px; }
    #wrap { position: relative; width: 100vw; height: 100vh; overflow: hidden; }
    video {
      position:absolute; inset:0; width:100%; height:100%; object-fit:cover;
      transform: scaleX(-1);
      opacity: .18;
      filter: saturate(1.1) contrast(1.05);
    }
    canvas { position:absolute; inset:0; display:block; }
    #hint { font-size: 13px; opacity:.9; }
  </style>
</head>
<body>
  <div class="top">
    <button id="startBtn">üé• Start</button>
    <span class="badge" id="status">Status: tayyor</span>
    <span id="hint">Pinch = energiya yig‚Äòish. Qo‚Äòl ochilsa = portlash. Barmoq bilan ‚Äúorb‚Äùni sudrab yuriting.</span>
  </div>

  <div id="wrap">
    <video id="video" playsinline></video>
    <canvas id="three"></canvas>
  </div>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const video = document.getElementById("video");
    const canvas = document.getElementById("three");
    const statusEl = document.getElementById("status");
    const startBtn = document.getElementById("startBtn");
    const wrap = document.getElementById("wrap");
    const setStatus = (t) => statusEl.textContent = "Status: " + t;

    // ---------- THREE ----------
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x02040a, 0.09);

    const cam = new THREE.PerspectiveCamera(55, 1, 0.01, 100);
    cam.position.set(0, 0.65, 2.5);

    const ambient = new THREE.AmbientLight(0xffffff, 0.35);
    scene.add(ambient);

    const key = new THREE.DirectionalLight(0xffffff, 0.85);
    key.position.set(2, 3, 2);
    scene.add(key);

    const rim = new THREE.DirectionalLight(0x66ccff, 0.55);
    rim.position.set(-2, 1.8, -2);
    scene.add(rim);

    function resize(){
      const w = wrap.clientWidth, h = wrap.clientHeight;
      renderer.setSize(w, h, false);
      cam.aspect = w / h;
      cam.updateProjectionMatrix();
    }
    window.addEventListener("resize", resize);
    resize();

    // ---------- STARFIELD (particles) ----------
    const STAR_COUNT = 1400;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(STAR_COUNT * 3);
    for (let i = 0; i < STAR_COUNT; i++){
      const r = 10 * Math.random();
      const theta = Math.random() * Math.PI * 2;
      const y = (Math.random() - 0.5) * 6;
      starPos[i*3+0] = Math.cos(theta) * r;
      starPos[i*3+1] = y;
      starPos[i*3+2] = Math.sin(theta) * r - 6;
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    const starMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.02, transparent: true, opacity: 0.75 });
    const stars = new THREE.Points(starGeo, starMat);
    scene.add(stars);

    // ---------- ORB (main object) ----------
    const orb = new THREE.Mesh(
      new THREE.SphereGeometry(0.14, 48, 48),
      new THREE.MeshStandardMaterial({ color: 0xffffff, metalness: 0.25, roughness: 0.25, emissive: 0x113355, emissiveIntensity: 0.6 })
    );
    orb.position.set(0, 0.45, 0);
    scene.add(orb);

    const glow = new THREE.Mesh(
      new THREE.SphereGeometry(0.22, 32, 32),
      new THREE.MeshBasicMaterial({ color: 0x55ccff, transparent: true, opacity: 0.14 })
    );
    glow.position.copy(orb.position);
    scene.add(glow);

    // ---------- HAND NEON LINES ----------
    // Minimal connections (ko‚Äòrinishi chiroyli bo‚Äòlishi uchun)
    const CONN = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],
      [0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20],
      [5,9],[9,13],[13,17]
    ];

    const MAX_HAND_POINTS = 21;
    const handGeo = new THREE.BufferGeometry();
    const handPos = new Float32Array(MAX_HAND_POINTS * 3);
    handGeo.setAttribute("position", new THREE.BufferAttribute(handPos, 3));

    const handPts = new THREE.Points(
      handGeo,
      new THREE.PointsMaterial({ color: 0x66ccff, size: 0.03, transparent: true, opacity: 0.95 })
    );
    scene.add(handPts);

    // line segments for connections
    const segCount = CONN.length;
    const segGeo = new THREE.BufferGeometry();
    const segPos = new Float32Array(segCount * 2 * 3); // each seg has 2 points
    segGeo.setAttribute("position", new THREE.BufferAttribute(segPos, 3));

    const handLines = new THREE.LineSegments(
      segGeo,
      new THREE.LineBasicMaterial({ color: 0x55ccff, transparent: true, opacity: 0.65 })
    );
    scene.add(handLines);

    // ---------- ENERGY BURST (re-usable particles) ----------
    const BURST_MAX = 900;
    const burstGeo = new THREE.BufferGeometry();
    const burstPos = new Float32Array(BURST_MAX * 3);
    const burstVel = new Float32Array(BURST_MAX * 3);
    const burstLife = new Float32Array(BURST_MAX);
    burstGeo.setAttribute("position", new THREE.BufferAttribute(burstPos, 3));
    const burstMat = new THREE.PointsMaterial({ color: 0x88ddff, size: 0.03, transparent: true, opacity: 0.0 });
    const burst = new THREE.Points(burstGeo, burstMat);
    scene.add(burst);

    function spawnBurst(at, power){
      // power: 0..1.5
      const n = Math.floor(220 + power * 480);
      for (let i = 0; i < n; i++){
        const idx = (Math.random() * BURST_MAX) | 0;
        burstPos[idx*3+0] = at.x;
        burstPos[idx*3+1] = at.y;
        burstPos[idx*3+2] = at.z;

        // random velocity (spherical)
        const a = Math.random() * Math.PI * 2;
        const u = (Math.random() * 2 - 1);
        const s = Math.sqrt(1 - u*u);
        const speed = 0.9 + Math.random() * (2.2 + power * 2.0);

        burstVel[idx*3+0] = Math.cos(a) * s * speed;
        burstVel[idx*3+1] = u * speed;
        burstVel[idx*3+2] = Math.sin(a) * s * speed;

        burstLife[idx] = 0.35 + Math.random() * (0.8 + power * 0.7);
      }
      burstMat.opacity = 0.85;
      burstGeo.attributes.position.needsUpdate = true;
    }

    // ---------- HAND INPUT ----------
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); // y=0

    function dist(a,b){
      const dx=a.x-b.x, dy=a.y-b.y;
      return Math.sqrt(dx*dx+dy*dy);
    }
    function isPinch(lm){
      return dist(lm[4], lm[8]) < 0.075; // iPhone uchun biroz yumshoq
    }

    // smoothing
    let smooth = {x:0, y:0};
    const ALPHA = 0.22; // silliqlik
    function smoothN(n){
      smooth.x += (n.x - smooth.x) * ALPHA;
      smooth.y += (n.y - smooth.y) * ALPHA;
      return {x: smooth.x, y: smooth.y};
    }

    function landmarkToNDC(lm){
      const x = (1 - lm.x) * 2 - 1;
      const y = -(lm.y * 2 - 1);
      return { x, y };
    }

    function ndcToWorldOnPlane(n){
      ndc.set(n.x, n.y);
      raycaster.setFromCamera(ndc, cam);
      const hit = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, hit);
      return hit;
    }

    // energy logic
    let pinching = false;
    let energy = 0;          // 0..1.6
    let lastSeen = 0;

    function updateHandNeon(lm){
      // lm normalized -> convert to a "fake 3D" space in front of camera for pretty look
      // We'll map to a plane-ish volume near orb
      const baseZ = -0.6;
      for (let i=0;i<MAX_HAND_POINTS;i++){
        const x = (0.5 - lm[i].x) * 1.6;    // left-right
        const y = (0.5 - lm[i].y) * -1.2 + 0.55; // up-down
        const z = baseZ + (lm[i].z || 0) * 0.8;  // depth (mediapipe z exists)
        handPos[i*3+0]=x; handPos[i*3+1]=y; handPos[i*3+2]=z;
      }
      handGeo.attributes.position.needsUpdate = true;

      // segments
      for (let s=0;s<segCount;s++){
        const [a,b]=CONN[s];
        segPos[s*6+0]=handPos[a*3+0];
        segPos[s*6+1]=handPos[a*3+1];
        segPos[s*6+2]=handPos[a*3+2];
        segPos[s*6+3]=handPos[b*3+0];
        segPos[s*6+4]=handPos[b*3+1];
        segPos[s*6+5]=handPos[b*3+2];
      }
      segGeo.attributes.position.needsUpdate = true;

      // opacity pulse with energy
      handLines.material.opacity = 0.35 + Math.min(0.55, energy * 0.4);
      handPts.material.opacity   = 0.65 + Math.min(0.35, energy * 0.25);
    }

    // ---------- MEDIAPIPE ----------
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.75,
      minTrackingConfidence: 0.75
    });

    hands.onResults((res) => {
      const t = performance.now();
      if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0) {
        setStatus("qo‚Äòl topilmadi");
        lastSeen = t;
        pinching = false;
        return;
      }

      const lm = res.multiHandLandmarks[0];
      updateHandNeon(lm);

      const pinchNow = isPinch(lm);
      const raw = landmarkToNDC(lm[8]); // index tip
      const n = smoothN(raw);

      // orb follow when pinching (drag in 3D-ish)
      if (pinchNow){
        const hit = ndcToWorldOnPlane(n);
        orb.position.x = hit.x;
        orb.position.z = hit.z;
        // y based on screen y
        const yUp = THREE.MathUtils.clamp((1 - (n.y + 1) / 2) * 1.7, 0.08, 1.75);
        orb.position.y = yUp;

        // charge energy
        energy = Math.min(1.6, energy + 0.035);
        setStatus("pinch: ON (energy " + energy.toFixed(2) + ")");
      } else {
        setStatus("ready");
      }

      // release burst when pinch ends
      if (!pinchNow && pinching) {
        spawnBurst(orb.position, energy);
        energy = 0;
      }
      pinching = pinchNow;
      lastSeen = t;
    });

    // ---------- CAMERA START ----------
    let mpCamera;
    startBtn.addEventListener("click", async () => {
      try {
        setStatus("kamera so‚Äòralyapti...");
        const stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" }, audio: false
        });
        video.srcObject = stream;
        await video.play();

        mpCamera = new Camera(video, {
          onFrame: async () => { await hands.send({ image: video }); },
          width: 1280, height: 720
        });
        mpCamera.start();
        setStatus("ishlayapti");
      } catch (e) {
        console.error(e);
        setStatus("xatolik: kamera ochilmadi");
        alert("Kamera ochilmadi. HTTPS va ruxsatlarni tekshiring.");
      }
    });

    // ---------- ANIMATE ----------
    const tmp = new THREE.Vector3();
    function tick(){
      const time = performance.now() * 0.001;

      // stars slow drift
      stars.rotation.y = time * 0.03;

      // orb glow pulse with energy
      glow.position.copy(orb.position);
      const pulse = 0.14 + Math.min(0.22, energy * 0.14) + Math.sin(time * 6) * 0.02;
      glow.material.opacity = pulse;
      orb.material.emissiveIntensity = 0.55 + Math.min(1.1, energy * 0.7);

      // burst physics
      let alive = 0;
      for (let i=0;i<BURST_MAX;i++){
        if (burstLife[i] > 0){
          alive++;
          burstLife[i] -= 0.016;

          burstPos[i*3+0] += burstVel[i*3+0] * 0.016;
          burstPos[i*3+1] += burstVel[i*3+1] * 0.016;
          burstPos[i*3+2] += burstVel[i*3+2] * 0.016;

          // gravity + damping
          burstVel[i*3+1] -= 0.9 * 0.016;
          burstVel[i*3+0] *= 0.985;
          burstVel[i*3+1] *= 0.985;
          burstVel[i*3+2] *= 0.985;
        }
      }
      if (alive === 0) burstMat.opacity *= 0.90;
      else burstMat.opacity = Math.max(0.25, burstMat.opacity * 0.985);
      burstGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, cam);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>