<!doctype html>
<html lang="uz">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Neon Hand FX (Stable iPhone)</title>
  <style>
    :root{
      --bg1:#050012;
      --bg2:#020b18;
      --neon:#66ccff;
      --neon2:#ff4fd8;
      --text:#eaf2ff;
    }
    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(1200px 900px at 20% 20%, #14003a 0%, var(--bg1) 35%, var(--bg2) 100%);
      color: var(--text);
      font-family: system-ui,-apple-system,Arial;
      overflow:hidden;
    }
    #wrap{ position:relative; width:100vw; height:100vh; overflow:hidden; }

    /* Kamera ishlaydi, lekin ko‚Äòrinmaydi */
    video{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      transform: scaleX(-1); /* foydalanuvchi uchun ‚Äúselfie‚Äù kabi */
      opacity:0;             /* üëà ko‚Äòrinmaydi */
      pointer-events:none;
    }

    canvas{ position:absolute; inset:0; display:block; }

    /* Cinematic vignette */
    #wrap::before{
      content:"";
      position:absolute; inset:-20%;
      background:
        radial-gradient(900px 700px at 50% 45%, rgba(0,0,0,0) 0%, rgba(0,0,0,.25) 45%, rgba(0,0,0,.55) 75%, rgba(0,0,0,.75) 100%),
        radial-gradient(900px 900px at 85% 25%, rgba(102,204,255,.10) 0%, rgba(0,0,0,0) 55%),
        radial-gradient(900px 900px at 20% 80%, rgba(255,79,216,.08) 0%, rgba(0,0,0,0) 55%);
      pointer-events:none;
    }

    .top{
      position:fixed; left:12px; top:12px; z-index:10;
      display:flex; gap:10px; align-items:center; flex-wrap:wrap;
      background:rgba(255,255,255,.07);
      border:1px solid rgba(255,255,255,.14);
      padding:10px 12px;
      border-radius:14px;
      backdrop-filter: blur(10px);
      box-shadow: 0 10px 35px rgba(0,0,0,.35);
      max-width: calc(100vw - 24px);
    }
    button{
      padding:10px 14px;
      border-radius:12px;
      border:0;
      cursor:pointer;
      background: linear-gradient(135deg, rgba(102,204,255,.95), rgba(255,79,216,.75));
      color:#06121a;
      font-weight:800;
    }
    .badge{ padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.09); font-size:13px; }
    #hint{ font-size:13px; opacity:.92; }
  </style>
</head>
<body>
  <div class="top">
    <button id="startBtn">‚ö° Start</button>
    <span class="badge" id="status">Status: ready</span>
    <span id="hint">ü§è Pinch = sudrash+energiya ‚Ä¢ ‚úã Open = portlash ‚Ä¢ ‚úä Fist = freeze ‚Ä¢ ‚ÜïÔ∏è Pinch+yuqori/past = zoom</span>
  </div>

  <div id="wrap">
    <video id="video" playsinline muted></video>
    <canvas id="three"></canvas>
  </div>

  <!-- MediaPipe -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script type="module">
    import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js";

    const wrap = document.getElementById("wrap");
    const video = document.getElementById("video");
    const canvas = document.getElementById("three");
    const startBtn = document.getElementById("startBtn");
    const statusEl = document.getElementById("status");
    const setStatus = (t)=> statusEl.textContent = "Status: " + t;

    // ---------- THREE SETUP ----------
    const renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setClearColor(0x000000, 0);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050012, 0.085);

    const cam = new THREE.PerspectiveCamera(58, 1, 0.01, 120);
    cam.position.set(0, 0.7, 2.9);

    scene.add(new THREE.AmbientLight(0xffffff, 0.28));
    const key = new THREE.DirectionalLight(0xffffff, 0.85); key.position.set(2.2, 3.2, 1.5); scene.add(key);
    const rim1 = new THREE.DirectionalLight(0x66ccff, 0.55); rim1.position.set(-2.2, 1.8, -2.2); scene.add(rim1);
    const rim2 = new THREE.DirectionalLight(0xff4fd8, 0.35); rim2.position.set(1.0, 1.2, -2.8); scene.add(rim2);

    function resize(){
      const w = wrap.clientWidth, h = wrap.clientHeight;
      renderer.setSize(w, h, false);
      cam.aspect = w / h;
      cam.updateProjectionMatrix();
    }
    window.addEventListener("resize", () => scheduleRestart("resize"));
    window.addEventListener("orientationchange", () => scheduleRestart("orientation"));

    resize();

    // ---------- STARFIELD ----------
    const STAR_COUNT = 1800;
    const starGeo = new THREE.BufferGeometry();
    const starPos = new Float32Array(STAR_COUNT*3);
    const starCol = new Float32Array(STAR_COUNT*3);

    function randn(){ return (Math.random()+Math.random()+Math.random()+Math.random()-2); }
    for (let i=0;i<STAR_COUNT;i++){
      const x = randn()*2.6;
      const y = randn()*1.9 + 0.25;
      const z = - (Math.random()*12 + 2);
      starPos[i*3+0]=x; starPos[i*3+1]=y; starPos[i*3+2]=z;

      const c1 = new THREE.Color(0x66ccff);
      const c2 = new THREE.Color(0xff4fd8);
      const c3 = new THREE.Color(0xffffff);
      const c = c1.clone().lerp(c2, Math.random()*0.55).lerp(c3, Math.random()*0.35);
      starCol[i*3+0]=c.r; starCol[i*3+1]=c.g; starCol[i*3+2]=c.b;
    }
    starGeo.setAttribute("position", new THREE.BufferAttribute(starPos, 3));
    starGeo.setAttribute("color", new THREE.BufferAttribute(starCol, 3));
    const stars = new THREE.Points(
      starGeo,
      new THREE.PointsMaterial({ size:0.022, vertexColors:true, transparent:true, opacity:0.86, depthWrite:false })
    );
    scene.add(stars);

    // ---------- ORB + GLOW ----------
    const orb = new THREE.Mesh(
      new THREE.SphereGeometry(0.16, 56, 56),
      new THREE.MeshStandardMaterial({ color:0xffffff, metalness:0.3, roughness:0.18, emissive:0x113355, emissiveIntensity:0.7 })
    );
    orb.position.set(0, 0.55, 0);
    scene.add(orb);

    const glow1 = new THREE.Mesh(
      new THREE.SphereGeometry(0.25, 32, 32),
      new THREE.MeshBasicMaterial({ color:0x66ccff, transparent:true, opacity:0.12, depthWrite:false })
    );
    const glow2 = new THREE.Mesh(
      new THREE.SphereGeometry(0.34, 32, 32),
      new THREE.MeshBasicMaterial({ color:0xff4fd8, transparent:true, opacity:0.06, depthWrite:false })
    );
    scene.add(glow1, glow2);

    // ---------- HAND NEON ----------
    const MAX = 21;
    const CONN = [
      [0,1],[1,2],[2,3],[3,4],
      [0,5],[5,6],[6,7],[7,8],
      [0,9],[9,10],[10,11],[11,12],
      [0,13],[13,14],[14,15],[15,16],
      [0,17],[17,18],[18,19],[19,20],
      [5,9],[9,13],[13,17]
    ];
    const segCount = CONN.length;

    const handGeo = new THREE.BufferGeometry();
    const handPos = new Float32Array(MAX*3);
    handGeo.setAttribute("position", new THREE.BufferAttribute(handPos, 3));
    const handPts = new THREE.Points(
      handGeo,
      new THREE.PointsMaterial({ color:0x66ccff, size:0.032, transparent:true, opacity:0.0, depthWrite:false })
    );
    scene.add(handPts);

    const segGeo = new THREE.BufferGeometry();
    const segPos = new Float32Array(segCount*2*3);
    segGeo.setAttribute("position", new THREE.BufferAttribute(segPos, 3));
    const handLines = new THREE.LineSegments(
      segGeo,
      new THREE.LineBasicMaterial({ color:0x55ccff, transparent:true, opacity:0.0 })
    );
    scene.add(handLines);

    // fingertip trail
    const TRAIL = 120;
    const trailGeo = new THREE.BufferGeometry();
    const trailPos = new Float32Array(TRAIL*3);
    trailGeo.setAttribute("position", new THREE.BufferAttribute(trailPos, 3));
    const trailMat = new THREE.LineBasicMaterial({ color:0xff4fd8, transparent:true, opacity:0.0 });
    const trailLine = new THREE.Line(trailGeo, trailMat);
    scene.add(trailLine);

    function pushTrail(p){
      for (let i=TRAIL-1;i>0;i--){
        trailPos[i*3+0]=trailPos[(i-1)*3+0];
        trailPos[i*3+1]=trailPos[(i-1)*3+1];
        trailPos[i*3+2]=trailPos[(i-1)*3+2];
      }
      trailPos[0]=p.x; trailPos[1]=p.y; trailPos[2]=p.z;
      trailGeo.attributes.position.needsUpdate = true;
    }

    // ---------- BURST ----------
    const BURST_MAX = 1200;
    const burstGeo = new THREE.BufferGeometry();
    const burstPos = new Float32Array(BURST_MAX*3);
    const burstVel = new Float32Array(BURST_MAX*3);
    const burstLife = new Float32Array(BURST_MAX);
    burstGeo.setAttribute("position", new THREE.BufferAttribute(burstPos, 3));
    const burstMat = new THREE.PointsMaterial({ color:0x88ddff, size:0.03, transparent:true, opacity:0.0, depthWrite:false });
    const burst = new THREE.Points(burstGeo, burstMat);
    scene.add(burst);

    function spawnBurst(at, power){
      const n = Math.floor(260 + power*620);
      for (let i=0;i<n;i++){
        const idx = (Math.random()*BURST_MAX)|0;
        burstPos[idx*3+0]=at.x; burstPos[idx*3+1]=at.y; burstPos[idx*3+2]=at.z;

        const a = Math.random()*Math.PI*2;
        const u = (Math.random()*2-1);
        const s = Math.sqrt(1-u*u);
        const speed = 1.1 + Math.random()*(2.6 + power*2.2);

        burstVel[idx*3+0]=Math.cos(a)*s*speed;
        burstVel[idx*3+1]=u*speed;
        burstVel[idx*3+2]=Math.sin(a)*s*speed;

        burstLife[idx]=0.5 + Math.random()*(0.9 + power*0.8);
      }
      burstMat.opacity = 0.9;
      burstGeo.attributes.position.needsUpdate = true;
    }

    // ---------- MAPPING (IMPORTANT: cover crop fix) ----------
    // Video real size comes from video.videoWidth / video.videoHeight.
    // Container size comes from wrap.clientWidth / clientHeight.
    // We map MediaPipe landmark x/y (0..1 in video space) -> screen space (cover crop aware).
    function mapLandmarkToScreen01(lm){
      const cw = wrap.clientWidth, ch = wrap.clientHeight;
      const vw = video.videoWidth || 1280;
      const vh = video.videoHeight || 720;

      // object-fit: cover scale
      const sx = cw / vw;
      const sy = ch / vh;
      const scale = Math.max(sx, sy);
      const scaledW = vw * scale;
      const scaledH = vh * scale;

      const offsetX = (scaledW - cw) / 2;
      const offsetY = (scaledH - ch) / 2;

      // landmark in scaled coords
      let x = lm.x * scaledW - offsetX;
      let y = lm.y * scaledH - offsetY;

      // clamp to screen
      x = Math.max(0, Math.min(cw, x));
      y = Math.max(0, Math.min(ch, y));

      // normalized in screen
      let nx = x / cw;
      let ny = y / ch;

      // we mirror video (scaleX(-1)), so we mirror control too:
      nx = 1 - nx;

      return { nx, ny };
    }

    function screen01ToNDC(nx, ny){
      // nx,ny in [0..1] screen
      const x = nx * 2 - 1;
      const y = -(ny * 2 - 1);
      return { x, y };
    }

    // ---------- GESTURES ----------
    function dist(a,b){
      const dx=a.x-b.x, dy=a.y-b.y;
      return Math.sqrt(dx*dx+dy*dy);
    }
    function isPinch(lm){ return dist(lm[4], lm[8]) < 0.09; }  // iPhone friendly
    function openness(lm){
      const palm = lm[0];
      const tips = [4,8,12,16,20];
      let s=0;
      for (const t of tips) s += dist(lm[t], palm);
      return s / tips.length;
    }
    function isOpenHand(lm){ return openness(lm) > 0.23; }
    function isFist(lm){ return openness(lm) < 0.16; }

    // smoothing
    let smooth = {x:0, y:0};
    const ALPHA = 0.26;
    function smoothN(n){
      smooth.x += (n.x - smooth.x) * ALPHA;
      smooth.y += (n.y - smooth.y) * ALPHA;
      return {x:smooth.x, y:smooth.y};
    }

    // 3D move
    const raycaster = new THREE.Raycaster();
    const ndc = new THREE.Vector2();
    const plane = new THREE.Plane(new THREE.Vector3(0,1,0), 0);
    function ndcToWorldOnPlane(n){
      ndc.set(n.x, n.y);
      raycaster.setFromCamera(ndc, cam);
      const hit = new THREE.Vector3();
      raycaster.ray.intersectPlane(plane, hit);
      return hit;
    }

    // state
    let pinching=false;
    let energy=0;     // 0..1.8
    let freeze=false;
    let lastOpen=false;
    let lastFist=false;

    function updateHandNeon(lm){
      // neon hand in ‚Äúpretty‚Äù space
      const baseZ = -0.75;
      for (let i=0;i<MAX;i++){
        const x = (0.5 - lm[i].x)*1.65;
        const y = (0.5 - lm[i].y)*-1.25 + 0.62;
        const z = baseZ + (lm[i].z || 0)*0.95;
        handPos[i*3+0]=x; handPos[i*3+1]=y; handPos[i*3+2]=z;
      }
      handGeo.attributes.position.needsUpdate = true;

      for (let s=0;s<segCount;s++){
        const [a,b]=CONN[s];
        segPos[s*6+0]=handPos[a*3+0];
        segPos[s*6+1]=handPos[a*3+1];
        segPos[s*6+2]=handPos[a*3+2];
        segPos[s*6+3]=handPos[b*3+0];
        segPos[s*6+4]=handPos[b*3+1];
        segPos[s*6+5]=handPos[b*3+2];
      }
      segGeo.attributes.position.needsUpdate = true;

      handPts.material.opacity = 0.92;
      handLines.material.opacity = 0.55;

      const e = Math.min(1.0, energy/1.4);
      handLines.material.opacity = 0.45 + e*0.35;
      trailMat.opacity = 0.12 + e*0.42;
    }

    // ---------- MEDIAPIPE ----------
    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
    });

    // ‚úÖ iPhone uchun ‚Äúaniq ishlashi‚Äù uchun yumshoqroq
    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.6,
      minTrackingConfidence: 0.6
    });

    hands.onResults((res) => {
      if (!res.multiHandLandmarks || res.multiHandLandmarks.length === 0){
        setStatus(freeze ? "freeze (qo‚Äòl yo‚Äòq)" : "qo‚Äòl topilmadi");
        handPts.material.opacity = 0.0;
        handLines.material.opacity = 0.0;
        trailMat.opacity *= 0.92;
        pinching=false; lastOpen=false; lastFist=false;
        return;
      }

      const lm = res.multiHandLandmarks[0];
      updateHandNeon(lm);

      const pinchNow = isPinch(lm);
      const openNow  = isOpenHand(lm);
      const fistNow  = isFist(lm);

      // ‚úä Fist toggles freeze (edge)
      if (fistNow && !lastFist){
        freeze = !freeze;
      }
      lastFist = fistNow;

      // ‚úã Open triggers burst (edge)
      if (openNow && !lastOpen){
        spawnBurst(orb.position, Math.min(1.2, 0.35 + energy));
        energy = 0;
      }
      lastOpen = openNow;

      // index tip -> screen mapping (cover-aware)
      const s01 = mapLandmarkToScreen01(lm[8]); // {nx,ny}
      const n0 = screen01ToNDC(s01.nx, s01.ny);
      const n  = smoothN(n0);

      // fingertip trail uses neon-space tip
      const tip3 = new THREE.Vector3(handPos[8*3+0], handPos[8*3+1], handPos[8*3+2]);
      pushTrail(tip3);

      if (!freeze){
        if (pinchNow){
          const hit = ndcToWorldOnPlane(n);
          orb.position.x = hit.x;
          orb.position.z = hit.z;

          // y from screen ny (0 top -> 1 bottom)
          const yUp = THREE.MathUtils.clamp((1 - s01.ny) * 1.9, 0.10, 1.95);
          orb.position.y = yUp;

          energy = Math.min(1.8, energy + 0.04);

          // pinch+up/down zoom
          const zoom = THREE.MathUtils.clamp(3.3 - yUp*0.9, 1.8, 4.2);
          cam.position.z = cam.position.z + (zoom - cam.position.z)*0.12;

          setStatus("pinch (energy " + energy.toFixed(2) + ")");
        } else {
          setStatus("running");
        }
      } else {
        setStatus("freeze ON");
      }

      // release pinch -> burst
      if (!pinchNow && pinching && !freeze){
        spawnBurst(orb.position, energy);
        energy = 0;
      }
      pinching = pinchNow;
    });

    // ---------- CAMERA PIPELINE (robust restart) ----------
    let mpCamera = null;
    let mediaStream = null;
    let running = false;
    let restartTimer = null;

    async function stopPipeline(){
      try{ if (mpCamera) mpCamera.stop(); } catch {}
      mpCamera = null;

      try{
        if (mediaStream){
          mediaStream.getTracks().forEach(t => t.stop());
        }
      } catch {}
      mediaStream = null;

      running = false;
    }

    async function startPipeline(){
      await stopPipeline();
      resize();

      setStatus("kamera...");
      // orientation-ga mos ‚Äúideal‚Äù size
      const cw = wrap.clientWidth, ch = wrap.clientHeight;
      const isLandscape = cw > ch;

      const constraints = {
        audio:false,
        video:{
          facingMode:"user",
          width:  { ideal: isLandscape ? 1280 : 720 },
          height: { ideal: isLandscape ? 720  : 1280 }
        }
      };

      mediaStream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = mediaStream;

      await new Promise((resolve) => {
        video.onloadedmetadata = () => resolve();
      });
      await video.play();

      // MediaPipe Camera uses displayed size to feed frames properly
      mpCamera = new Camera(video, {
        onFrame: async () => { await hands.send({ image: video }); },
        width: wrap.clientWidth,
        height: wrap.clientHeight
      });
      mpCamera.start();
      running = true;
      setStatus("running");
    }

    function scheduleRestart(reason){
      // faqat ishlayotgan bo‚Äòlsa restart qilamiz
      if (!running) { resize(); return; }
      if (restartTimer) clearTimeout(restartTimer);
      restartTimer = setTimeout(async () => {
        try{
          setStatus("restart...");
          await startPipeline();
        }catch(e){
          console.error(e);
          setStatus("xatolik (restart)");
        }
      }, 350);
    }

    startBtn.addEventListener("click", async () => {
      try{
        await startPipeline();
      }catch(e){
        console.error(e);
        setStatus("kamera ochilmadi");
        alert("Kamera ochilmadi. Safari ruxsatlarini tekshiring (HTTPS bo‚Äòlishi shart).");
      }
    });

    // ---------- ANIMATE ----------
    function tick(){
      const t = performance.now()*0.001;

      stars.rotation.y = t*0.06;
      stars.position.x = Math.sin(t*0.08)*0.15;

      const e = Math.min(1.0, energy/1.4);
      glow1.position.copy(orb.position);
      glow2.position.copy(orb.position);
      glow1.material.opacity = 0.10 + e*0.25 + Math.sin(t*6)*0.02;
      glow2.material.opacity = 0.05 + e*0.14 + Math.sin(t*4+1.3)*0.015;
      orb.material.emissiveIntensity = 0.65 + e*1.15;

      // burst physics
      let alive=0;
      for (let i=0;i<BURST_MAX;i++){
        if (burstLife[i] > 0){
          alive++;
          burstLife[i] -= 0.016;
          burstPos[i*3+0] += burstVel[i*3+0]*0.016;
          burstPos[i*3+1] += burstVel[i*3+1]*0.016;
          burstPos[i*3+2] += burstVel[i*3+2]*0.016;

          burstVel[i*3+1] -= 0.95*0.016;
          burstVel[i*3+0] *= 0.986;
          burstVel[i*3+1] *= 0.986;
          burstVel[i*3+2] *= 0.986;
        }
      }
      if (alive===0) burstMat.opacity *= 0.92;
      else burstMat.opacity = Math.max(0.25, burstMat.opacity*0.987);
      burstGeo.attributes.position.needsUpdate = true;

      renderer.render(scene, cam);
      requestAnimationFrame(tick);
    }
    tick();
  </script>
</body>
</html>